import hana from '@sap/hana-client';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Get HANA configuration from env vars
 */
export const getDatabaseConfig = () => {
  const required = ['HANA_HOST', 'HANA_PORT', 'HANA_USER', 'HANA_PASSWORD', 'HANA_DATABASE'];
  const missing = required.filter((v) => !process.env[v]);
  if (missing.length) throw new Error(`Missing required env vars: ${missing.join(', ')}`);

  const parseBool = (v, fallback) => ['true', '1', 'yes'].includes(String(v)?.toLowerCase()) ?? fallback;

  return {
    serverNode: `${process.env.HANA_HOST}:${process.env.HANA_PORT}`,
    uid: process.env.HANA_USER,
    pwd: process.env.HANA_PASSWORD,
    databaseName: process.env.HANA_DATABASE,
    encrypt: parseBool(process.env.HANA_ENCRYPT, true),
    sslValidateCertificate: parseBool(process.env.HANA_SSL_VALIDATE_CERT, false),
    sslCryptoProvider: process.env.HANA_SSL_CRYPTO_PROVIDER || 'openssl',
    sslTrustStore: process.env.HANA_SSL_TRUST_STORE
  };
};

const config = getDatabaseConfig();

/**
 * Get a single HANA connection
 */
export const getConnection = () =>
  new Promise((resolve, reject) => {
    const conn = hana.createConnection();
    conn.connect(config, (err) => {
      if (err) reject(err);
      else resolve(conn);
    });
  });

/**
 * Execute a query and disconnect
 */
export const executeQuery = async (query, params = []) => {
  const conn = await getConnection();
  return new Promise((resolve, reject) => {
    conn.exec(query, params, (err, rows) => {
      conn.disconnect();
      if (err) reject(err);
      else resolve({ recordset: rows || [] });
    });
  });
};

/**
 * Pool-like interface for controllers
 */
export const getPool = async () => ({ request: () => createRequest() });

const createRequest = () => {
  const inputs = {};
  return {
    input(name, _type, value) {
      inputs[name] = value;
      return this;
    },
    async query(sql) {
      const params = Object.values(inputs);
      return executeQuery(sql, params);
    }
  };
};

/**
 * SQL type placeholders
 */
export const sql = {
  NVarChar: (length) => ({ type: 'NVarChar', length }),
  DateTime2: { type: 'DateTime2' },
  Decimal: (precision, scale) => ({ type: 'Decimal', precision, scale }),
  Bit: { type: 'Bit' },
  MAX: 2147483647
};

/**
 * Ensure database schema exists
 */
export const ensureSchema = async () => {
  const conn = await getConnection();

  const execStatement = (conn, sql, params = []) =>
    new Promise((resolve, reject) => {
      conn.exec(sql, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });

  const tableExists = async (conn, tableName) => {
    const res = await execStatement(
      conn,
      `SELECT COUNT(*) AS CNT FROM TABLES WHERE TABLE_NAME = ? AND SCHEMA_NAME = CURRENT_SCHEMA`,
      [tableName.toUpperCase()]
    );
    return res[0].CNT > 0;
  };

  const indexExists = async (conn, indexName) => {
    const res = await execStatement(
      conn,
      `SELECT COUNT(*) AS CNT FROM INDEXES WHERE INDEX_NAME = ? AND SCHEMA_NAME = CURRENT_SCHEMA`,
      [indexName.toUpperCase()]
    );
    return res[0].CNT > 0;
  };

  const createTableIfNotExists = async (conn, name, createSQL) => {
    if (!(await tableExists(conn, name))) {
      await execStatement(conn, createSQL);
      console.log(`Table ${name} created.`);
    } else console.log(`Table ${name} exists.`);
  };

  const createIndexIfNotExists = async (conn, name, createSQL) => {
    if (!(await indexExists(conn, name))) {
      await execStatement(conn, createSQL);
      console.log(`Index ${name} created.`);
    } else console.log(`Index ${name} exists.`);
  };

  const tables = [
    {
      name: 'Users',
      sql: `CREATE TABLE Users (
        Id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        Name NVARCHAR(150) NOT NULL,
        Email NVARCHAR(255) NOT NULL UNIQUE,
        PasswordHash NVARCHAR(255) NOT NULL,
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`
    },
    {
      name: 'ParameterMaster',
      sql: `CREATE TABLE ParameterMaster (
        Id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        ParameterType NVARCHAR(100) NOT NULL,
        ParameterName NVARCHAR(150) NOT NULL,
        ProcessProduct NVARCHAR(150) NOT NULL,
        SpecCharacteristic NVARCHAR(150) NOT NULL,
        ParameterCode NVARCHAR(100) NOT NULL,
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`
    }
    // Add other tables here...
  ];

  const indexes = [
    {
      name: 'IX_ParameterMaster_CreatedAt',
      sql: `CREATE INDEX IX_ParameterMaster_CreatedAt ON ParameterMaster (CreatedAt DESC)`
    }
    // Add other indexes here...
  ];

  for (const { name, sql } of tables) await createTableIfNotExists(conn, name, sql);
  for (const { name, sql } of indexes) await createIndexIfNotExists(conn, name, sql);

  console.log('Database schema initialized successfully.');
  conn.disconnect();
};
